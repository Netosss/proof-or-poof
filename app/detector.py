import logging
import cv2
import numpy as np
from app.c2pa_reader import get_c2pa_manifest
from app.runpod_client import run_deep_forensics

logger = logging.getLogger(__name__)

def get_fft_score(image_path: str) -> float:
    """
    Perform Fast Fourier Transform to detect artificial frequency patterns (grids/checkerboards).
    """
    try:
        img = cv2.imread(image_path, 0)
        if img is None:
            return 0.0
        dft = np.fft.fft2(img)
        dft_shift = np.fft.fftshift(dft)
        magnitude_spectrum = 20 * np.log(np.abs(dft_shift) + 1e-9)
        mean_val = np.mean(magnitude_spectrum)
        peaks = np.sum(magnitude_spectrum > (mean_val * 1.6))
        score = min(peaks / 5000, 1.0)
        return float(score)
    except Exception as e:
        logger.error(f"Error in FFT analysis: {e}")
        return 0.0

async def detect_ai_media(file_path: str) -> dict:
    """
    Consensus Engine for AI detection.
    Layer 1: C2PA Metadata (Source of Truth) - Local
    Layer 2: FFT Math (Local)
    Layer 3: Deep Forensic Analysis (Offloaded to RunPod GPU)
    """
    
    # --- Layer 1: Metadata Check (C2PA) ---
    manifest = get_c2pa_manifest(file_path)
    l1_data = {
        "status": "not_found",
        "provider": None,
        "description": "No cryptographic signature found. Digital 'passport' may have been stripped."
    }
    
    is_verified_ai = False
    is_ai_modified = False
    is_verified_human = False
    
    if manifest:
        gen_info = manifest.get("claim_generator_info", [])
        if gen_info and isinstance(gen_info, list) and len(gen_info) > 0:
            generator = gen_info[0].get("name", "Unknown AI")
        else:
            generator = manifest.get("claim_generator", "Unknown AI")

        is_generative_ai = False
        is_modified_by_ai = False
        
        assertions = manifest.get("assertions", [])
        for assertion in assertions:
            if assertion.get("label") == "c2pa.actions.v2":
                actions = assertion.get("data", {}).get("actions", [])
                for action in actions:
                    source_type = action.get("digitalSourceType", "")
                    desc = action.get("description", "").lower()
                    
                    if "trainedAlgorithmicMedia" in source_type:
                        is_generative_ai = True
                    if any(term in desc for term in ["generative fill", "ai-modified", "edited with ai"]):
                        is_modified_by_ai = True
                    if "generative ai" in desc or "ai generated" in desc:
                        is_generative_ai = True
            if is_generative_ai:
                break

        if is_generative_ai:
            is_verified_ai = True
            l1_data = {
                "status": "verified_ai",
                "provider": generator,
                "description": f"Verified AI signature found. Generated by {generator}."
            }
        elif is_modified_by_ai:
            is_ai_modified = True
            l1_data = {
                "status": "ai_modified",
                "provider": generator,
                "description": f"Verified signature found, but indicates image was modified by AI (e.g., Generative Fill)."
            }
        else:
            is_verified_human = True
            l1_data = {
                "status": "verified_human",
                "provider": generator,
                "description": "Cryptographic signature found. Verified as non-generative content (e.g., camera capture)."
            }

    # --- EARLY EXIT: If Layer 1 is 100% Verified AI, skip RunPod ---
    if is_verified_ai:
        return {
            "summary": "Verified AI",
            "confidence_score": 1.0,
            "layers": {
                "layer1_metadata": l1_data,
                "layer2_forensics": {
                    "status": "skipped",
                    "probability": 0.0,
                    "signals": ["Skipped: Metadata already provides 100% verification."]
                }
            }
        }

    # --- Layer 2 & 3: Local FFT + Offloaded Deep Forensic ---
    # FFT is instant on Railway
    fft_score = get_fft_score(file_path)
    
    # SigLIP is offloaded to RunPod GPU (approx 1-2 seconds)
    logger.info("Offloading Deep Forensic scan to RunPod GPU...")
    deep_score = await run_deep_forensics(file_path)
    
    # Final forensic probability
    forensic_probability = (deep_score * 0.85) + (fft_score * 0.15)
    
    l2_data = {
        "status": "not_detected",
        "probability": round(forensic_probability, 4),
        "signals": []
    }
    
    if deep_score > 0.8:
        l2_data["signals"].append("Deep Learning identifies generative AI textures")
    if fft_score > 0.5:
        l2_data["signals"].append("Artificial frequency patterns detected (FFT)")
    
    if forensic_probability > 0.7:
        l2_data["status"] = "detected"
    elif forensic_probability > 0.3:
        l2_data["status"] = "suspicious"
    else:
        l2_data["status"] = "not_detected"
        if not l2_data["signals"]:
            l2_data["signals"].append("Pixel DNA appears consistent with natural photography")

    # --- Consensus Calculation ---
    if is_ai_modified:
        summary = "AI Modified"
        confidence_score = 0.95
    elif is_verified_human:
        # Overrule forensics if we have hard cryptographic proof it's human
        summary = "Verified Human"
        confidence_score = 1.0
    else:
        # FALLBACK: Use Forensic Layer
        if forensic_probability > 0.8:
            summary = "Likely AI (Forensic Match)"
        elif forensic_probability > 0.5:
            summary = "Possible AI (Suspicious Patterns)"
        elif forensic_probability > 0.2:
            summary = "Likely Human (Minor Noise)"
        else:
            summary = "Likely Human"
        confidence_score = forensic_probability if forensic_probability > 0.5 else (1.0 - forensic_probability)
        
    return {
        "summary": summary,
        "confidence_score": round(confidence_score, 2),
        "layers": {
            "layer1_metadata": l1_data,
            "layer2_forensics": l2_data
        }
    }
